# Сортировки

## Сортировка вставками (Insertion sort)

Идея: В каждый момент времени массив разделён на две части: отсортированную (слева) и неотсортированную (справа).

На очередной шаге берём первый элемент из неотсортированной части и направляем его в отсортированную часть.

Продолжаем, пока не отсортированная часть не опустеет.

```python3
def insertion_sort(arr):
    for i in range(1, len(arr)):
        j = i
        while j > 0 and arr[j - 1] > arr[j]:
            arr[j - 1], arr[j] = arr[j], arr[j - 1]
            j -= 1
```

Внешний цикл: Проходим по всем элементам , начиная со второго.

Внутренний цикл: Пока не дошли до начала массива меняем элементы местами

Сложность: $O(n^2)$

## Можно ли быстрее?

Да, можно. Например, с помощью сортировки слиянием.

## Слияние

Решим задачу попроше: даны два отсортированных массива, нужно объединить их в один отсортированный.

Идея: воспользуемся методом "двух указателей"

```python3
def merge(a, b):
    res = []
    i, j = 0, 0
    while i < len(a) and j < len(b):
        if b[j] < a[i]:
            res.append(b[j])
            j += 1
        else:
            res.append(a[i])
            i += 1
    res.extend(a[i:])
    res.extend(b[j:])
    return res
```

Сложность: $O(n_a + n_b)

## Сортировка слиянием (merge sort)

Сортировка слиянием - сортировка оптимистов

Дано $n$ отсортированных массивов длины 1

Идея: будем объединять массивы попарно, пока не получим один отсортированный массив.

Наиболее простым образом алгоритм реализуется рекурсивно

```python3
def merge_sort(arr):
    if len(arr) <= 1:
        return arr
    mid = len(arr) // 2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    return merge(left, right)
```

Сложность: $O(n log n)$

Дополнительная память: $O(n)$
![merge_sort.png](pictures/merge_sort.png)
## Быстрая сортировка (Quick Sort)

В предыдущем алгоритме мы сортировали две части массива, а затем собирали их вместе.

Идея быстрой сортировки немного обратная

### Разбиение

Что значит переупорядочить нужным образом?

Это значит, разбить массив на 2 части так, чтобы в первой были элементы, меньше либо равные, чем во второй (разбиение)

Идея: Если нам удастся выполнить разбиение, то затем будет достаточно рекурсивно отсортировать две части

Существует несколько способов выполнить разбиение. одним ииз наиболее простых является разбиение Хоара:

Идея: Выбираем некоторый опорный элемент $x$. Ищем первый элемент слева, который $\geq x$ и первый элемент справа,
который $\leq x$. Меняем их местами. Повторяем, пока левый и правый указатели не встретятся 

![partition.png](pictures/partition.png)

```python3
def partition(arr, l, r):
    x = arr[(l + r) // 2]
    i, j = l, r
    while True:
        while arr[i] < x:
            i += 1
        while arr[j] > x:
            j -= 1
        if i >= j:
            return j
        arr[i], arr[j] = arr[j], arr[i]
        i += 1
        j -= 1
```

Сложность $O(n)$


## Быстрая сортировка (Quick Sort)
```python3
def quick_sort(arr, l, r): 
    if l < r:
        m = partition(arr, l, r)
        quick_sort(arr, l,  m)
        quick_sort(arr, m + 1, r)
```

Сложность зависит от того, как выполняется разбиение. 

Если опорный элемент выбирается неудачно (так, что отделяется несколько элементов), то сложность будет $O(n^2)$

Если опорный элемент разбивает массив на примерно равные части, то сложность будет $O(n log n)

На практике, опорный элемент выбирают случайно. Это позволяет защититься от специально подобранных сложных случаев.

В таком случае говорят, что алгоритм работает в среднем за $O(n log n)$ 

## Можно ли ещё быстрее?
Нет.

Теорема. 
Сортировки, основанные на сравнениях, работают за $\Upomega (n log n)$ в среднем.

Доказательство (если успеем)

Однако! Если помимо сравненй можно использовать другие операции, то можно сортировать быстрее (в том числе за линейное время).