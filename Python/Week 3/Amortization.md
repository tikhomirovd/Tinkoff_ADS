# Амортизация

list. В него можно добавлять элементы. append(x) -- $O(1)$

А как это реализовано?

Каждая ячейка листа занимает 8 байт и хранит ссылку на элемент.

В листе хранится сразу две характеристике. Size и Capacity

Список при создании создаётся не с размером с Size, а с Capacity (это чуть больше)

- Size -- реальный размер массива (сколько реально в нём хранится элементов)
- Capacity -- с запасом памяти

Но что если мы выйдем за пределы Capacity?

1. Есть массив размером $k$. Делаем $k$ вставок по $O(1)$
2. Хотим добавить ещё $k$, для этого копируем все элементы в новый массив и выделяем ещё $2k$ capacity
3. Копирую $2k$ элементов.. $k$ вставок за 1

$$k + 2k + 3k + ... + \frac{n}{k} k = k c \frac{n^2}{k}$$

План провалился, давайте ещё подумаем

Давайте увеличивать массив не на $k$ штук, а в $k$ раз

1. вставка за 1
2. Увеличиваю в k раз(1 коп-е + k_1 вставка)
3. k копирований + $k^2 - k$ вставок
4. $k^2$ копирований + $k^3 - k^2$ вставок
5. ....

Допустим вставили $n$ элементов. $n = k^{log n}$

$$ 1 + (k + k - 1) + (k + k^2 -k) + ... + k^{log n -1} = \frac{k^{log n} - 1}{k -1} \approx n \frac{k}{k -1}$$

Амортизация заключается в том, что если в нашей последовательности действий можно считать, что в среднем она работает за
линию, то можно в среднем считать, что каждая операция занимает какое-то фиксированное время

## Известная задача, которая использует идею амортизации

У нас есть массив размера $n$. По этому массиву двигается некоторое окошко $k$. Окошко видит элементы. Окошко можно или
передвинуть на единицу вправо или спросить минимум.

### Стек с поддержкой минимума

Поддерживает 3 операции

1. append
2. pop
3. min

Текущий минимум будем хранить в отдельной переменной. Если пришло число меньше, то мы перезатираем минимальное число и
записываем туда. Но проблема когда мы удаляем минимальный.

Идея. В новом стеке хранить минимум из k чисел. Если index=2, то записывается минимум index чисел
$$k = min(s[:k])$$

### Очередь

1. append
2. pop_front

Реализация с помощью двух стеков

Храним два стека. В один стек мы добавляем элементы (append), из другого стека удаляем элементы (pop_front).
Когда приходит операция append, добавляем в первый влево.

Теперь приходит запрос, удалить элемент из начала.

Если я буду удалять из начала первого стека, то это будет линейное время.

Поэтому мы проворачиваем схему, и все элементы из первого стека строго по порядку перенесём в другой стек. Таким образом
у нас элементы будут в обратном порядке. И мы можем спокойно сделать pop_front

А что если первый стек огромный? Переносить его не очень хочется.

**Утверждение**: Суммарно мы потратим линейное время

Рассмотрим каждый элемент по отдельности? Что мы с ним делаем?

1. Добавление (append) (1)
2. Переход из append в pop front (2)
3. Удаление из pop front (1)

Сложность $O(4n) = O(n)$

Несмотря на то, что какие-то операции могут выполняться долго, мы никогда не превысим сложность 4n

**Проделать эксперимент с capacity и уменьшением памяти**

Хотим доделать операцию min. Что делать?

Давайте вместо стеков использовать стеки с поддержкой минимума

Раз у нас стеки умеют быть крутыми, надо это использовать.

Благодаря этой структуре данных мы можем решить задачу.

Задача минимума в скользящем окне

## Задача поинтереснее

Есть список из n элементов.

n раз запрашиваю 4.

Если не делать swap, то потратить $n^2$ jпераций.

Если можно делать swap, то $n+n$

[1, 4, 2, 3, 5]

Любой x можно вытаскивать наружу и становится первым элементом

[1, 2, 3, 4, 5]

[5, 4, 3, 2, 1]

**Утверждение**: Проиграю не более чем в 4 раза

Пусть есть идеальная стратегия $A*$

Идеальная стратегия, когда участник знает ответы и можем переупорядочить массив

$A$ -- наша стратегия (move to front)

Пусть $t_i$ -- время $A$ на обработку $x_i$

Пусть $t_i^*$ - время $A*$ на обработку $x_i$

Пусть есть функция $f(L_i)= 2*$ количество инверсий в списке $A$ по сравнению со списком $A*$ после $i-$го шага 

Инверсия -- кол-во пар, которые идут не в том порядке. 

Раcсмотрим такое выражение: $$t_i + f(L_i) - F(L_i - 1) \leq (2k - 1) + 2*(m - 1 - (k - m) + s_i) = 2k -1 + 2m -2 -2k + 2m + 2s_i = 4m + 2s_i - 3 \leq 4(m + s_i)  = 4t*_i$$

$x -- k-$ый элемент в списке. Чтобы его найти мы потратим $2k + 1$ времени. 

В самом худшем случае мы потратим (m - 1) операций по сравнению с идеальным алгоритмом 

s_i - число обменов $A*$ на $i$-ом шаге

Теперь суммируем обе части неравенство по $i$
$$\sum_{i=1}^{ы} t_i + \sum_{i=1}^{ы} F(L_{t_i}) \leq \sum_{i = 0}^{ы}t*_i $$

Мы доказали что сумма была по $t_i$ она будет не более чем в  4 раза хуже идеальной. Вау, катарсис.  


## Вводный проект для Advanced части
Написать функцию clone(id)

```python
def clone(object_id: int):
    """будет список элементов, которые могут быть"""
    return object 


def get_type_by_id(id):
    pass
```


