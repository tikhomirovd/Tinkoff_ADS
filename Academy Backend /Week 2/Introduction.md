# Академия бэкэнда
Александр Чернов

## 12-и факторное приложение 

### I. Кодовая база
**Система контроля версий**

Кодовая база - это один репозиторий или множество репозиториев, 
имеющих общие начальные коммиты (в децентрализованных системах контроля 
версий, как Git)

### II. Зависимости
**Явно декларируйте и изолируйте зависимости**

Приложение никогда не должно зависеть от неявного присутствия системных пакетов.  
Нужно использовать инструменты изоляции зависимостей, которые гарантируют 
"непротекание" зависимостей из внешней среды.

Более того, приложение не дожлно зависеть от "системных" тулов (будь то shell, curl) 

### III. Конфигурация
**Конфигурация приложения – это всё, что может меняться между развёртываниями**

Идентификаторы подключения к ресурсам типа базы данных данных, кэш-памяти и другим сторонним службам. 

Регистрационные данные для подключения к внешним сервисам, например, к Amazon S3 или Twitter

Значения зависимые от среды развёртывания такие, как каноническое имя хоста

**Код и конфиги должны строго разделяться. Использовать env** 

### IV. Сторонние службы
**Считайте сторонние службы подключаемыми ресурсами** 

Сторонняя сложба – это любая служба, которая доступна приложению по сети и необходима как часть его нормальной работы. 

Например, хранилища данных (MySQL, CouchDB), системы очередей сообщений (RabbitMQ, Beanstalkd), 
службы SMTP для исходящей электронной почты (Postfix) и кэширующие системы (MemCached)

**И внешние и "внутренние" сторонние службы обрабатываются одинаково**

**Чистая\Генсагональная\Луковая архитектура**

Позволяет взаимодействовать с приложением как пользователю, так и программам,
автоматическим тестам, скриптам пакетной обработки. Также позволяет разрабатывать
и тестировать приложение без каких-либо дополнительных устройств или баз данных.

### V. Сборка, релиз, выполнение
**Строго разделяйте стадии сборки и выполнения** 

Этап сборки – это трансформация, которая преобразует репозиторий кода в исполняемый пакет, называемый сборка.
Используя версию кода по указанному процессом развёртывания коммиту, этап сборки загружает сторонние зависимости и 
компилирует двоичные файлы и ресурсы (assets) 

Этап релиза принимает сборку, полученную на этапе сборки, и объединяет её с текущей 
конфигурацией развёртывания. Полученный релиз содержит сборку и конфигурацию и готов
к немедленному запуску в среде выполнения. 

Этап выполнения (также известный как "runtime") запускает приложение в среде выполнения путём 
запуска некоторго набора процессов приложения из определённого релиза. 

### VI. Процессы
**Запускайте приложение как один или несколько процессов, не сохраняющих внутреннее состояние (stateles)**

Процессы приложения двенадцати факторов не сохраняют внутреннее состояние и не имеют разделяемых данных. 
Любые данных, которые требуется сохранить, должны быть сохранены в хранящей состояние сторонней службе, обычно, в базе данных

Плюсы:
- Хорошо горизонтально масштабируется
- Можем запустить много приложений, которые будут работать параллельно, и они никак не будут между собой конфликтовать 

Минусы: 
- Неэффективность. Мы плати тем, что на любой чих надо сходить во внешнюю систему. Это замедляет работу программы  

### VII. Привязка портов (Port Binding)
**Экспортируйте сервисы через привязку портов**

HTTP – это не единственный сервис, который может быть экспортирован посредством привязки порта. 
Почти любой тип серверного ПО может быть запушен как процесс, привязанный к порту и ожидающий входящих
запросов. Примеры этого включают ejabberd (предоставляет XMPP протокол) и Redis (предоставляет Redis протокол) 

Порт рассматривается как уникальный идентификатор сервиса, с которым мы будем взаимодействовать. 


### VIII. Параллелизм
**Рост нагрузки** 

Есть три способа масштабируемости

1. Горизонтальное, увеличиваем кол-во инстансов
2. Вертикальное, улучшаем железо
3. Функциональное, разделяем приложение на части из-за неразрешимости требований 

Масштабировать базу намного сложнее. У каждого пункта несколько своих минусов. 

1. Упрёмся в ограничение в базу
2. Упрёмся в ограничение по железу
3. Дробим приложение, благодаря чему мы независимо можем улучшать производительность каждых этапов,
в зависимости от потребностей. Что-то работает с одной базой, что-то с другой

### IX. Утилизируемость (Disposability)
**Максимизируйте надёжность с помощью быстрого запуска и корректного завершения работы**

Процессы приложения двенадцати факторов являются утилизируемыми, это означает, что
они могут быть запущены и остановлены в любой момент. Это способствует стабильному
и гибкому масштабированию, быстрому развёртыванию, изменений кода и конфигураций и надёжности рабочего развёртывания. 

### X. Паритет разработки\работы приложения
**Держите окружения разработки, промежуточного развёртывания (staging) и рабочего развёртывания
(production) максимально похожими.**

Разичие во времени: разработчик может работать с кодом, который попадёт в рабочую версию приложения только через дни, 
недели или даже месяцы. 

Раличие персонала: разработчики пишут код, OPS инженеры разворачивают его. 

Различие инструментов: разработчики могут использовать стек технологий, такой как Nginx, SQLite и OS X, 
в то время как при рабочем развёртывании используются Apache, MySQL и Linux 


### XI. Журналирование (Logs)
**Рассматривайте журнал как поток событий** 

- grep
- ELK
- sage / bump

### XII. Задачи администрирования
**As code** 

Для того, чтобы контролировать изменения необходимо вести аудит всех действий
и иметь возможность воспроизводимости. 

Поэтому сейчас существует тенденция выполнять любые действия через CI\CD апйплайн

**Инфраструктура, как код** 
